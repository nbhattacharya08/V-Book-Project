{"ast":null,"code":"import { attributeRules } from \"./attributes.js\";\nimport { compilePseudoSelector } from \"./pseudo-selectors/index.js\";\nimport { SelectorType } from \"css-what\";\nfunction getElementParent(node, adapter) {\n  const parent = adapter.getParent(node);\n  if (parent && adapter.isTag(parent)) {\n    return parent;\n  }\n  return null;\n}\n/*\n * All available rules\n */\nexport function compileGeneralSelector(next, selector, options, context, compileToken) {\n  const {\n    adapter,\n    equals\n  } = options;\n  switch (selector.type) {\n    case SelectorType.PseudoElement:\n      {\n        throw new Error(\"Pseudo-elements are not supported by css-select\");\n      }\n    case SelectorType.ColumnCombinator:\n      {\n        throw new Error(\"Column combinators are not yet supported by css-select\");\n      }\n    case SelectorType.Attribute:\n      {\n        if (selector.namespace != null) {\n          throw new Error(\"Namespaced attributes are not yet supported by css-select\");\n        }\n        if (!options.xmlMode || options.lowerCaseAttributeNames) {\n          selector.name = selector.name.toLowerCase();\n        }\n        return attributeRules[selector.action](next, selector, options);\n      }\n    case SelectorType.Pseudo:\n      {\n        return compilePseudoSelector(next, selector, options, context, compileToken);\n      }\n    // Tags\n    case SelectorType.Tag:\n      {\n        if (selector.namespace != null) {\n          throw new Error(\"Namespaced tag names are not yet supported by css-select\");\n        }\n        let {\n          name\n        } = selector;\n        if (!options.xmlMode || options.lowerCaseTags) {\n          name = name.toLowerCase();\n        }\n        return function tag(elem) {\n          return adapter.getName(elem) === name && next(elem);\n        };\n      }\n    // Traversal\n    case SelectorType.Descendant:\n      {\n        if (options.cacheResults === false || typeof WeakSet === \"undefined\") {\n          return function descendant(elem) {\n            let current = elem;\n            while (current = getElementParent(current, adapter)) {\n              if (next(current)) {\n                return true;\n              }\n            }\n            return false;\n          };\n        }\n        // @ts-expect-error `ElementNode` is not extending object\n        const isFalseCache = new WeakSet();\n        return function cachedDescendant(elem) {\n          let current = elem;\n          while (current = getElementParent(current, adapter)) {\n            if (!isFalseCache.has(current)) {\n              if (adapter.isTag(current) && next(current)) {\n                return true;\n              }\n              isFalseCache.add(current);\n            }\n          }\n          return false;\n        };\n      }\n    case \"_flexibleDescendant\":\n      {\n        // Include element itself, only used while querying an array\n        return function flexibleDescendant(elem) {\n          let current = elem;\n          do {\n            if (next(current)) return true;\n          } while (current = getElementParent(current, adapter));\n          return false;\n        };\n      }\n    case SelectorType.Parent:\n      {\n        return function parent(elem) {\n          return adapter.getChildren(elem).some(elem => adapter.isTag(elem) && next(elem));\n        };\n      }\n    case SelectorType.Child:\n      {\n        return function child(elem) {\n          const parent = adapter.getParent(elem);\n          return parent != null && adapter.isTag(parent) && next(parent);\n        };\n      }\n    case SelectorType.Sibling:\n      {\n        return function sibling(elem) {\n          const siblings = adapter.getSiblings(elem);\n          for (let i = 0; i < siblings.length; i++) {\n            const currentSibling = siblings[i];\n            if (equals(elem, currentSibling)) break;\n            if (adapter.isTag(currentSibling) && next(currentSibling)) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n    case SelectorType.Adjacent:\n      {\n        if (adapter.prevElementSibling) {\n          return function adjacent(elem) {\n            const previous = adapter.prevElementSibling(elem);\n            return previous != null && next(previous);\n          };\n        }\n        return function adjacent(elem) {\n          const siblings = adapter.getSiblings(elem);\n          let lastElement;\n          for (let i = 0; i < siblings.length; i++) {\n            const currentSibling = siblings[i];\n            if (equals(elem, currentSibling)) break;\n            if (adapter.isTag(currentSibling)) {\n              lastElement = currentSibling;\n            }\n          }\n          return !!lastElement && next(lastElement);\n        };\n      }\n    case SelectorType.Universal:\n      {\n        if (selector.namespace != null && selector.namespace !== \"*\") {\n          throw new Error(\"Namespaced universal selectors are not yet supported by css-select\");\n        }\n        return next;\n      }\n  }\n}","map":{"version":3,"sources":["general.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import { attributeRules } from \"./attributes.js\";\nimport { compilePseudoSelector } from \"./pseudo-selectors/index.js\";\nimport { SelectorType } from \"css-what\";\nfunction getElementParent(node, adapter) {\n    const parent = adapter.getParent(node);\n    if (parent && adapter.isTag(parent)) {\n        return parent;\n    }\n    return null;\n}\n/*\n * All available rules\n */\nexport function compileGeneralSelector(next, selector, options, context, compileToken) {\n    const { adapter, equals } = options;\n    switch (selector.type) {\n        case SelectorType.PseudoElement: {\n            throw new Error(\"Pseudo-elements are not supported by css-select\");\n        }\n        case SelectorType.ColumnCombinator: {\n            throw new Error(\"Column combinators are not yet supported by css-select\");\n        }\n        case SelectorType.Attribute: {\n            if (selector.namespace != null) {\n                throw new Error(\"Namespaced attributes are not yet supported by css-select\");\n            }\n            if (!options.xmlMode || options.lowerCaseAttributeNames) {\n                selector.name = selector.name.toLowerCase();\n            }\n            return attributeRules[selector.action](next, selector, options);\n        }\n        case SelectorType.Pseudo: {\n            return compilePseudoSelector(next, selector, options, context, compileToken);\n        }\n        // Tags\n        case SelectorType.Tag: {\n            if (selector.namespace != null) {\n                throw new Error(\"Namespaced tag names are not yet supported by css-select\");\n            }\n            let { name } = selector;\n            if (!options.xmlMode || options.lowerCaseTags) {\n                name = name.toLowerCase();\n            }\n            return function tag(elem) {\n                return adapter.getName(elem) === name && next(elem);\n            };\n        }\n        // Traversal\n        case SelectorType.Descendant: {\n            if (options.cacheResults === false ||\n                typeof WeakSet === \"undefined\") {\n                return function descendant(elem) {\n                    let current = elem;\n                    while ((current = getElementParent(current, adapter))) {\n                        if (next(current)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n            }\n            // @ts-expect-error `ElementNode` is not extending object\n            const isFalseCache = new WeakSet();\n            return function cachedDescendant(elem) {\n                let current = elem;\n                while ((current = getElementParent(current, adapter))) {\n                    if (!isFalseCache.has(current)) {\n                        if (adapter.isTag(current) && next(current)) {\n                            return true;\n                        }\n                        isFalseCache.add(current);\n                    }\n                }\n                return false;\n            };\n        }\n        case \"_flexibleDescendant\": {\n            // Include element itself, only used while querying an array\n            return function flexibleDescendant(elem) {\n                let current = elem;\n                do {\n                    if (next(current))\n                        return true;\n                } while ((current = getElementParent(current, adapter)));\n                return false;\n            };\n        }\n        case SelectorType.Parent: {\n            return function parent(elem) {\n                return adapter\n                    .getChildren(elem)\n                    .some((elem) => adapter.isTag(elem) && next(elem));\n            };\n        }\n        case SelectorType.Child: {\n            return function child(elem) {\n                const parent = adapter.getParent(elem);\n                return parent != null && adapter.isTag(parent) && next(parent);\n            };\n        }\n        case SelectorType.Sibling: {\n            return function sibling(elem) {\n                const siblings = adapter.getSiblings(elem);\n                for (let i = 0; i < siblings.length; i++) {\n                    const currentSibling = siblings[i];\n                    if (equals(elem, currentSibling))\n                        break;\n                    if (adapter.isTag(currentSibling) && next(currentSibling)) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n        }\n        case SelectorType.Adjacent: {\n            if (adapter.prevElementSibling) {\n                return function adjacent(elem) {\n                    const previous = adapter.prevElementSibling(elem);\n                    return previous != null && next(previous);\n                };\n            }\n            return function adjacent(elem) {\n                const siblings = adapter.getSiblings(elem);\n                let lastElement;\n                for (let i = 0; i < siblings.length; i++) {\n                    const currentSibling = siblings[i];\n                    if (equals(elem, currentSibling))\n                        break;\n                    if (adapter.isTag(currentSibling)) {\n                        lastElement = currentSibling;\n                    }\n                }\n                return !!lastElement && next(lastElement);\n            };\n        }\n        case SelectorType.Universal: {\n            if (selector.namespace != null && selector.namespace !== \"*\") {\n                throw new Error(\"Namespaced universal selectors are not yet supported by css-select\");\n            }\n            return next;\n        }\n    }\n}\n//# sourceMappingURL=general.js.map"]},"metadata":{},"sourceType":"module"}