{"ast":null,"code":"import boolbase from \"boolbase\";\nimport { isTraversal } from \"../sort.js\";\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\nexport const PLACEHOLDER_ELEMENT = {};\nexport function ensureIsTag(next, adapter) {\n  if (next === boolbase.falseFunc) return boolbase.falseFunc;\n  return elem => adapter.isTag(elem) && next(elem);\n}\nexport function getNextSiblings(elem, adapter) {\n  const siblings = adapter.getSiblings(elem);\n  if (siblings.length <= 1) return [];\n  const elemIndex = siblings.indexOf(elem);\n  if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];\n  return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\nfunction copyOptions(options) {\n  // Not copied: context, rootFunc\n  return {\n    xmlMode: !!options.xmlMode,\n    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,\n    lowerCaseTags: !!options.lowerCaseTags,\n    quirksMode: !!options.quirksMode,\n    cacheResults: !!options.cacheResults,\n    pseudos: options.pseudos,\n    adapter: options.adapter,\n    equals: options.equals\n  };\n}\nconst is = (next, token, options, context, compileToken) => {\n  const func = compileToken(token, copyOptions(options), context);\n  return func === boolbase.trueFunc ? next : func === boolbase.falseFunc ? boolbase.falseFunc : elem => func(elem) && next(elem);\n};\n/*\n * :not, :has, :is, :matches and :where have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\nexport const subselects = {\n  is,\n  /**\n   * `:matches` and `:where` are aliases for `:is`.\n   */\n  matches: is,\n  where: is,\n  not(next, token, options, context, compileToken) {\n    const func = compileToken(token, copyOptions(options), context);\n    return func === boolbase.falseFunc ? next : func === boolbase.trueFunc ? boolbase.falseFunc : elem => !func(elem) && next(elem);\n  },\n  has(next, subselect, options, _context, compileToken) {\n    const {\n      adapter\n    } = options;\n    const opts = copyOptions(options);\n    opts.relativeSelector = true;\n    const context = subselect.some(s => s.some(isTraversal)) ?\n    // Used as a placeholder. Will be replaced with the actual element.\n    [PLACEHOLDER_ELEMENT] : undefined;\n    const compiled = compileToken(subselect, opts, context);\n    if (compiled === boolbase.falseFunc) return boolbase.falseFunc;\n    const hasElement = ensureIsTag(compiled, adapter);\n    // If `compiled` is `trueFunc`, we can skip this.\n    if (context && compiled !== boolbase.trueFunc) {\n      /*\n       * `shouldTestNextSiblings` will only be true if the query starts with\n       * a traversal (sibling or adjacent). That means we will always have a context.\n       */\n      const {\n        shouldTestNextSiblings = false\n      } = compiled;\n      return elem => {\n        if (!next(elem)) return false;\n        context[0] = elem;\n        const childs = adapter.getChildren(elem);\n        const nextElements = shouldTestNextSiblings ? [...childs, ...getNextSiblings(elem, adapter)] : childs;\n        return adapter.existsOne(hasElement, nextElements);\n      };\n    }\n    return elem => next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));\n  }\n};","map":{"version":3,"sources":["pseudo-selectors/subselects.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import boolbase from \"boolbase\";\nimport { isTraversal } from \"../sort.js\";\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\nexport const PLACEHOLDER_ELEMENT = {};\nexport function ensureIsTag(next, adapter) {\n    if (next === boolbase.falseFunc)\n        return boolbase.falseFunc;\n    return (elem) => adapter.isTag(elem) && next(elem);\n}\nexport function getNextSiblings(elem, adapter) {\n    const siblings = adapter.getSiblings(elem);\n    if (siblings.length <= 1)\n        return [];\n    const elemIndex = siblings.indexOf(elem);\n    if (elemIndex < 0 || elemIndex === siblings.length - 1)\n        return [];\n    return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\nfunction copyOptions(options) {\n    // Not copied: context, rootFunc\n    return {\n        xmlMode: !!options.xmlMode,\n        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,\n        lowerCaseTags: !!options.lowerCaseTags,\n        quirksMode: !!options.quirksMode,\n        cacheResults: !!options.cacheResults,\n        pseudos: options.pseudos,\n        adapter: options.adapter,\n        equals: options.equals,\n    };\n}\nconst is = (next, token, options, context, compileToken) => {\n    const func = compileToken(token, copyOptions(options), context);\n    return func === boolbase.trueFunc\n        ? next\n        : func === boolbase.falseFunc\n            ? boolbase.falseFunc\n            : (elem) => func(elem) && next(elem);\n};\n/*\n * :not, :has, :is, :matches and :where have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\nexport const subselects = {\n    is,\n    /**\n     * `:matches` and `:where` are aliases for `:is`.\n     */\n    matches: is,\n    where: is,\n    not(next, token, options, context, compileToken) {\n        const func = compileToken(token, copyOptions(options), context);\n        return func === boolbase.falseFunc\n            ? next\n            : func === boolbase.trueFunc\n                ? boolbase.falseFunc\n                : (elem) => !func(elem) && next(elem);\n    },\n    has(next, subselect, options, _context, compileToken) {\n        const { adapter } = options;\n        const opts = copyOptions(options);\n        opts.relativeSelector = true;\n        const context = subselect.some((s) => s.some(isTraversal))\n            ? // Used as a placeholder. Will be replaced with the actual element.\n                [PLACEHOLDER_ELEMENT]\n            : undefined;\n        const compiled = compileToken(subselect, opts, context);\n        if (compiled === boolbase.falseFunc)\n            return boolbase.falseFunc;\n        const hasElement = ensureIsTag(compiled, adapter);\n        // If `compiled` is `trueFunc`, we can skip this.\n        if (context && compiled !== boolbase.trueFunc) {\n            /*\n             * `shouldTestNextSiblings` will only be true if the query starts with\n             * a traversal (sibling or adjacent). That means we will always have a context.\n             */\n            const { shouldTestNextSiblings = false } = compiled;\n            return (elem) => {\n                if (!next(elem))\n                    return false;\n                context[0] = elem;\n                const childs = adapter.getChildren(elem);\n                const nextElements = shouldTestNextSiblings\n                    ? [...childs, ...getNextSiblings(elem, adapter)]\n                    : childs;\n                return adapter.existsOne(hasElement, nextElements);\n            };\n        }\n        return (elem) => next(elem) &&\n            adapter.existsOne(hasElement, adapter.getChildren(elem));\n    },\n};\n//# sourceMappingURL=subselects.js.map"]},"metadata":{},"sourceType":"module"}