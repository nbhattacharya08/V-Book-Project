{"ast":null,"code":"import * as DomUtils from \"domutils\";\nimport boolbase from \"boolbase\";\nimport { compile as compileRaw, compileUnsafe, compileToken } from \"./compile.js\";\nimport { getNextSiblings } from \"./pseudo-selectors/subselects.js\";\nconst defaultEquals = (a, b) => a === b;\nconst defaultOptions = {\n  adapter: DomUtils,\n  equals: defaultEquals\n};\nfunction convertOptionFormats(options) {\n  var _a, _b, _c, _d;\n  /*\n   * We force one format of options to the other one.\n   */\n  // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.\n  const opts = options !== null && options !== void 0 ? options : defaultOptions;\n  // @ts-expect-error Same as above.\n  (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;\n  // @ts-expect-error `equals` does not exist on `Options`\n  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;\n  return opts;\n}\nfunction wrapCompile(func) {\n  return function addAdapter(selector, options, context) {\n    const opts = convertOptionFormats(options);\n    return func(selector, opts, context);\n  };\n}\n/**\n * Compiles the query, returns a function.\n */\nexport const compile = wrapCompile(compileRaw);\nexport const _compileUnsafe = wrapCompile(compileUnsafe);\nexport const _compileToken = wrapCompile(compileToken);\nfunction getSelectorFunc(searchFunc) {\n  return function select(query, elements, options) {\n    const opts = convertOptionFormats(options);\n    if (typeof query !== \"function\") {\n      query = compileUnsafe(query, opts, elements);\n    }\n    const filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);\n    return searchFunc(query, filteredElements, opts);\n  };\n}\nexport function prepareContext(elems, adapter) {\n  let shouldTestNextSiblings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  /*\n   * Add siblings if the query requires them.\n   * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692\n   */\n  if (shouldTestNextSiblings) {\n    elems = appendNextSiblings(elems, adapter);\n  }\n  return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);\n}\nfunction appendNextSiblings(elem, adapter) {\n  // Order matters because jQuery seems to check the children before the siblings\n  const elems = Array.isArray(elem) ? elem.slice(0) : [elem];\n  const elemsLength = elems.length;\n  for (let i = 0; i < elemsLength; i++) {\n    const nextSiblings = getNextSiblings(elems[i], adapter);\n    elems.push(...nextSiblings);\n  }\n  return elems;\n}\n/**\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elems Elements to query. If it is an element, its children will be queried..\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns All matching elements.\n *\n */\nexport const selectAll = getSelectorFunc((query, elems, options) => query === boolbase.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems));\n/**\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elems Elements to query. If it is an element, its children will be queried..\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns the first match, or null if there was no match.\n */\nexport const selectOne = getSelectorFunc((query, elems, options) => query === boolbase.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems));\n/**\n * Tests whether or not an element is matched by query.\n *\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elem The element to test if it matches the query.\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns\n */\nexport function is(elem, query, options) {\n  const opts = convertOptionFormats(options);\n  return (typeof query === \"function\" ? query : compileRaw(query, opts))(elem);\n}\n/**\n * Alias for selectAll(query, elems, options).\n * @see [compile] for supported selector queries.\n */\nexport default selectAll;\n// Export filters, pseudos and aliases to allow users to supply their own.\n/** @deprecated Use the `pseudos` option instead. */\nexport { filters, pseudos, aliases } from \"./pseudo-selectors/index.js\";","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import * as DomUtils from \"domutils\";\nimport boolbase from \"boolbase\";\nimport { compile as compileRaw, compileUnsafe, compileToken, } from \"./compile.js\";\nimport { getNextSiblings } from \"./pseudo-selectors/subselects.js\";\nconst defaultEquals = (a, b) => a === b;\nconst defaultOptions = {\n    adapter: DomUtils,\n    equals: defaultEquals,\n};\nfunction convertOptionFormats(options) {\n    var _a, _b, _c, _d;\n    /*\n     * We force one format of options to the other one.\n     */\n    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.\n    const opts = options !== null && options !== void 0 ? options : defaultOptions;\n    // @ts-expect-error Same as above.\n    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);\n    // @ts-expect-error `equals` does not exist on `Options`\n    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);\n    return opts;\n}\nfunction wrapCompile(func) {\n    return function addAdapter(selector, options, context) {\n        const opts = convertOptionFormats(options);\n        return func(selector, opts, context);\n    };\n}\n/**\n * Compiles the query, returns a function.\n */\nexport const compile = wrapCompile(compileRaw);\nexport const _compileUnsafe = wrapCompile(compileUnsafe);\nexport const _compileToken = wrapCompile(compileToken);\nfunction getSelectorFunc(searchFunc) {\n    return function select(query, elements, options) {\n        const opts = convertOptionFormats(options);\n        if (typeof query !== \"function\") {\n            query = compileUnsafe(query, opts, elements);\n        }\n        const filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);\n        return searchFunc(query, filteredElements, opts);\n    };\n}\nexport function prepareContext(elems, adapter, shouldTestNextSiblings = false) {\n    /*\n     * Add siblings if the query requires them.\n     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692\n     */\n    if (shouldTestNextSiblings) {\n        elems = appendNextSiblings(elems, adapter);\n    }\n    return Array.isArray(elems)\n        ? adapter.removeSubsets(elems)\n        : adapter.getChildren(elems);\n}\nfunction appendNextSiblings(elem, adapter) {\n    // Order matters because jQuery seems to check the children before the siblings\n    const elems = Array.isArray(elem) ? elem.slice(0) : [elem];\n    const elemsLength = elems.length;\n    for (let i = 0; i < elemsLength; i++) {\n        const nextSiblings = getNextSiblings(elems[i], adapter);\n        elems.push(...nextSiblings);\n    }\n    return elems;\n}\n/**\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elems Elements to query. If it is an element, its children will be queried..\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns All matching elements.\n *\n */\nexport const selectAll = getSelectorFunc((query, elems, options) => query === boolbase.falseFunc || !elems || elems.length === 0\n    ? []\n    : options.adapter.findAll(query, elems));\n/**\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elems Elements to query. If it is an element, its children will be queried..\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns the first match, or null if there was no match.\n */\nexport const selectOne = getSelectorFunc((query, elems, options) => query === boolbase.falseFunc || !elems || elems.length === 0\n    ? null\n    : options.adapter.findOne(query, elems));\n/**\n * Tests whether or not an element is matched by query.\n *\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elem The element to test if it matches the query.\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns\n */\nexport function is(elem, query, options) {\n    const opts = convertOptionFormats(options);\n    return (typeof query === \"function\" ? query : compileRaw(query, opts))(elem);\n}\n/**\n * Alias for selectAll(query, elems, options).\n * @see [compile] for supported selector queries.\n */\nexport default selectAll;\n// Export filters, pseudos and aliases to allow users to supply their own.\n/** @deprecated Use the `pseudos` option instead. */\nexport { filters, pseudos, aliases } from \"./pseudo-selectors/index.js\";\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}