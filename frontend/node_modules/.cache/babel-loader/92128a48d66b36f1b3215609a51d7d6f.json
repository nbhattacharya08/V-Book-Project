{"ast":null,"code":"import getNCheck from \"nth-check\";\nimport boolbase from \"boolbase\";\nfunction getChildFunc(next, adapter) {\n  return elem => {\n    const parent = adapter.getParent(elem);\n    return parent != null && adapter.isTag(parent) && next(elem);\n  };\n}\nexport const filters = {\n  contains(next, text, _ref) {\n    let {\n      adapter\n    } = _ref;\n    return function contains(elem) {\n      return next(elem) && adapter.getText(elem).includes(text);\n    };\n  },\n  icontains(next, text, _ref2) {\n    let {\n      adapter\n    } = _ref2;\n    const itext = text.toLowerCase();\n    return function icontains(elem) {\n      return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);\n    };\n  },\n  // Location specific methods\n  \"nth-child\"(next, rule, _ref3) {\n    let {\n      adapter,\n      equals\n    } = _ref3;\n    const func = getNCheck(rule);\n    if (func === boolbase.falseFunc) return boolbase.falseFunc;\n    if (func === boolbase.trueFunc) return getChildFunc(next, adapter);\n    return function nthChild(elem) {\n      const siblings = adapter.getSiblings(elem);\n      let pos = 0;\n      for (let i = 0; i < siblings.length; i++) {\n        if (equals(elem, siblings[i])) break;\n        if (adapter.isTag(siblings[i])) {\n          pos++;\n        }\n      }\n      return func(pos) && next(elem);\n    };\n  },\n  \"nth-last-child\"(next, rule, _ref4) {\n    let {\n      adapter,\n      equals\n    } = _ref4;\n    const func = getNCheck(rule);\n    if (func === boolbase.falseFunc) return boolbase.falseFunc;\n    if (func === boolbase.trueFunc) return getChildFunc(next, adapter);\n    return function nthLastChild(elem) {\n      const siblings = adapter.getSiblings(elem);\n      let pos = 0;\n      for (let i = siblings.length - 1; i >= 0; i--) {\n        if (equals(elem, siblings[i])) break;\n        if (adapter.isTag(siblings[i])) {\n          pos++;\n        }\n      }\n      return func(pos) && next(elem);\n    };\n  },\n  \"nth-of-type\"(next, rule, _ref5) {\n    let {\n      adapter,\n      equals\n    } = _ref5;\n    const func = getNCheck(rule);\n    if (func === boolbase.falseFunc) return boolbase.falseFunc;\n    if (func === boolbase.trueFunc) return getChildFunc(next, adapter);\n    return function nthOfType(elem) {\n      const siblings = adapter.getSiblings(elem);\n      let pos = 0;\n      for (let i = 0; i < siblings.length; i++) {\n        const currentSibling = siblings[i];\n        if (equals(elem, currentSibling)) break;\n        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {\n          pos++;\n        }\n      }\n      return func(pos) && next(elem);\n    };\n  },\n  \"nth-last-of-type\"(next, rule, _ref6) {\n    let {\n      adapter,\n      equals\n    } = _ref6;\n    const func = getNCheck(rule);\n    if (func === boolbase.falseFunc) return boolbase.falseFunc;\n    if (func === boolbase.trueFunc) return getChildFunc(next, adapter);\n    return function nthLastOfType(elem) {\n      const siblings = adapter.getSiblings(elem);\n      let pos = 0;\n      for (let i = siblings.length - 1; i >= 0; i--) {\n        const currentSibling = siblings[i];\n        if (equals(elem, currentSibling)) break;\n        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {\n          pos++;\n        }\n      }\n      return func(pos) && next(elem);\n    };\n  },\n  // TODO determine the actual root element\n  root(next, _rule, _ref7) {\n    let {\n      adapter\n    } = _ref7;\n    return elem => {\n      const parent = adapter.getParent(elem);\n      return (parent == null || !adapter.isTag(parent)) && next(elem);\n    };\n  },\n  scope(next, rule, options, context) {\n    const {\n      equals\n    } = options;\n    if (!context || context.length === 0) {\n      // Equivalent to :root\n      return filters[\"root\"](next, rule, options);\n    }\n    if (context.length === 1) {\n      // NOTE: can't be unpacked, as :has uses this for side-effects\n      return elem => equals(context[0], elem) && next(elem);\n    }\n    return elem => context.includes(elem) && next(elem);\n  },\n  hover: dynamicStatePseudo(\"isHovered\"),\n  visited: dynamicStatePseudo(\"isVisited\"),\n  active: dynamicStatePseudo(\"isActive\")\n};\n/**\n * Dynamic state pseudos. These depend on optional Adapter methods.\n *\n * @param name The name of the adapter method to call.\n * @returns Pseudo for the `filters` object.\n */\nfunction dynamicStatePseudo(name) {\n  return function dynamicPseudo(next, _rule, _ref8) {\n    let {\n      adapter\n    } = _ref8;\n    const func = adapter[name];\n    if (typeof func !== \"function\") {\n      return boolbase.falseFunc;\n    }\n    return function active(elem) {\n      return func(elem) && next(elem);\n    };\n  };\n}","map":{"version":3,"sources":["pseudo-selectors/filters.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import getNCheck from \"nth-check\";\nimport boolbase from \"boolbase\";\nfunction getChildFunc(next, adapter) {\n    return (elem) => {\n        const parent = adapter.getParent(elem);\n        return parent != null && adapter.isTag(parent) && next(elem);\n    };\n}\nexport const filters = {\n    contains(next, text, { adapter }) {\n        return function contains(elem) {\n            return next(elem) && adapter.getText(elem).includes(text);\n        };\n    },\n    icontains(next, text, { adapter }) {\n        const itext = text.toLowerCase();\n        return function icontains(elem) {\n            return (next(elem) &&\n                adapter.getText(elem).toLowerCase().includes(itext));\n        };\n    },\n    // Location specific methods\n    \"nth-child\"(next, rule, { adapter, equals }) {\n        const func = getNCheck(rule);\n        if (func === boolbase.falseFunc)\n            return boolbase.falseFunc;\n        if (func === boolbase.trueFunc)\n            return getChildFunc(next, adapter);\n        return function nthChild(elem) {\n            const siblings = adapter.getSiblings(elem);\n            let pos = 0;\n            for (let i = 0; i < siblings.length; i++) {\n                if (equals(elem, siblings[i]))\n                    break;\n                if (adapter.isTag(siblings[i])) {\n                    pos++;\n                }\n            }\n            return func(pos) && next(elem);\n        };\n    },\n    \"nth-last-child\"(next, rule, { adapter, equals }) {\n        const func = getNCheck(rule);\n        if (func === boolbase.falseFunc)\n            return boolbase.falseFunc;\n        if (func === boolbase.trueFunc)\n            return getChildFunc(next, adapter);\n        return function nthLastChild(elem) {\n            const siblings = adapter.getSiblings(elem);\n            let pos = 0;\n            for (let i = siblings.length - 1; i >= 0; i--) {\n                if (equals(elem, siblings[i]))\n                    break;\n                if (adapter.isTag(siblings[i])) {\n                    pos++;\n                }\n            }\n            return func(pos) && next(elem);\n        };\n    },\n    \"nth-of-type\"(next, rule, { adapter, equals }) {\n        const func = getNCheck(rule);\n        if (func === boolbase.falseFunc)\n            return boolbase.falseFunc;\n        if (func === boolbase.trueFunc)\n            return getChildFunc(next, adapter);\n        return function nthOfType(elem) {\n            const siblings = adapter.getSiblings(elem);\n            let pos = 0;\n            for (let i = 0; i < siblings.length; i++) {\n                const currentSibling = siblings[i];\n                if (equals(elem, currentSibling))\n                    break;\n                if (adapter.isTag(currentSibling) &&\n                    adapter.getName(currentSibling) === adapter.getName(elem)) {\n                    pos++;\n                }\n            }\n            return func(pos) && next(elem);\n        };\n    },\n    \"nth-last-of-type\"(next, rule, { adapter, equals }) {\n        const func = getNCheck(rule);\n        if (func === boolbase.falseFunc)\n            return boolbase.falseFunc;\n        if (func === boolbase.trueFunc)\n            return getChildFunc(next, adapter);\n        return function nthLastOfType(elem) {\n            const siblings = adapter.getSiblings(elem);\n            let pos = 0;\n            for (let i = siblings.length - 1; i >= 0; i--) {\n                const currentSibling = siblings[i];\n                if (equals(elem, currentSibling))\n                    break;\n                if (adapter.isTag(currentSibling) &&\n                    adapter.getName(currentSibling) === adapter.getName(elem)) {\n                    pos++;\n                }\n            }\n            return func(pos) && next(elem);\n        };\n    },\n    // TODO determine the actual root element\n    root(next, _rule, { adapter }) {\n        return (elem) => {\n            const parent = adapter.getParent(elem);\n            return (parent == null || !adapter.isTag(parent)) && next(elem);\n        };\n    },\n    scope(next, rule, options, context) {\n        const { equals } = options;\n        if (!context || context.length === 0) {\n            // Equivalent to :root\n            return filters[\"root\"](next, rule, options);\n        }\n        if (context.length === 1) {\n            // NOTE: can't be unpacked, as :has uses this for side-effects\n            return (elem) => equals(context[0], elem) && next(elem);\n        }\n        return (elem) => context.includes(elem) && next(elem);\n    },\n    hover: dynamicStatePseudo(\"isHovered\"),\n    visited: dynamicStatePseudo(\"isVisited\"),\n    active: dynamicStatePseudo(\"isActive\"),\n};\n/**\n * Dynamic state pseudos. These depend on optional Adapter methods.\n *\n * @param name The name of the adapter method to call.\n * @returns Pseudo for the `filters` object.\n */\nfunction dynamicStatePseudo(name) {\n    return function dynamicPseudo(next, _rule, { adapter }) {\n        const func = adapter[name];\n        if (typeof func !== \"function\") {\n            return boolbase.falseFunc;\n        }\n        return function active(elem) {\n            return func(elem) && next(elem);\n        };\n    };\n}\n//# sourceMappingURL=filters.js.map"]},"metadata":{},"sourceType":"module"}