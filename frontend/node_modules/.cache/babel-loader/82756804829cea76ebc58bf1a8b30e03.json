{"ast":null,"code":"import htmlDecodeTree from \"./generated/decode-data-html.js\";\nimport xmlDecodeTree from \"./generated/decode-data-xml.js\";\nimport decodeCodePoint from \"./decode_codepoint.js\";\n// Re-export for use by eg. htmlparser2\nexport { htmlDecodeTree, xmlDecodeTree, decodeCodePoint };\nexport { replaceCodePoint, fromCodePoint } from \"./decode_codepoint.js\";\nvar CharCodes;\n(function (CharCodes) {\n  CharCodes[CharCodes[\"NUM\"] = 35] = \"NUM\";\n  CharCodes[CharCodes[\"SEMI\"] = 59] = \"SEMI\";\n  CharCodes[CharCodes[\"ZERO\"] = 48] = \"ZERO\";\n  CharCodes[CharCodes[\"NINE\"] = 57] = \"NINE\";\n  CharCodes[CharCodes[\"LOWER_A\"] = 97] = \"LOWER_A\";\n  CharCodes[CharCodes[\"LOWER_F\"] = 102] = \"LOWER_F\";\n  CharCodes[CharCodes[\"LOWER_X\"] = 120] = \"LOWER_X\";\n  /** Bit that needs to be set to convert an upper case ASCII character to lower case */\n  CharCodes[CharCodes[\"To_LOWER_BIT\"] = 32] = \"To_LOWER_BIT\";\n})(CharCodes || (CharCodes = {}));\nexport var BinTrieFlags;\n(function (BinTrieFlags) {\n  BinTrieFlags[BinTrieFlags[\"VALUE_LENGTH\"] = 49152] = \"VALUE_LENGTH\";\n  BinTrieFlags[BinTrieFlags[\"BRANCH_LENGTH\"] = 16256] = \"BRANCH_LENGTH\";\n  BinTrieFlags[BinTrieFlags[\"JUMP_TABLE\"] = 127] = \"JUMP_TABLE\";\n})(BinTrieFlags || (BinTrieFlags = {}));\nfunction getDecoder(decodeTree) {\n  return function decodeHTMLBinary(str, strict) {\n    let ret = \"\";\n    let lastIdx = 0;\n    let strIdx = 0;\n    while ((strIdx = str.indexOf(\"&\", strIdx)) >= 0) {\n      ret += str.slice(lastIdx, strIdx);\n      lastIdx = strIdx;\n      // Skip the \"&\"\n      strIdx += 1;\n      // If we have a numeric entity, handle this separately.\n      if (str.charCodeAt(strIdx) === CharCodes.NUM) {\n        // Skip the leading \"&#\". For hex entities, also skip the leading \"x\".\n        let start = strIdx + 1;\n        let base = 10;\n        let cp = str.charCodeAt(start);\n        if ((cp | CharCodes.To_LOWER_BIT) === CharCodes.LOWER_X) {\n          base = 16;\n          strIdx += 1;\n          start += 1;\n        }\n        do cp = str.charCodeAt(++strIdx); while (cp >= CharCodes.ZERO && cp <= CharCodes.NINE || base === 16 && (cp | CharCodes.To_LOWER_BIT) >= CharCodes.LOWER_A && (cp | CharCodes.To_LOWER_BIT) <= CharCodes.LOWER_F);\n        if (start !== strIdx) {\n          const entity = str.substring(start, strIdx);\n          const parsed = parseInt(entity, base);\n          if (str.charCodeAt(strIdx) === CharCodes.SEMI) {\n            strIdx += 1;\n          } else if (strict) {\n            continue;\n          }\n          ret += decodeCodePoint(parsed);\n          lastIdx = strIdx;\n        }\n        continue;\n      }\n      let resultIdx = 0;\n      let excess = 1;\n      let treeIdx = 0;\n      let current = decodeTree[treeIdx];\n      for (; strIdx < str.length; strIdx++, excess++) {\n        treeIdx = determineBranch(decodeTree, current, treeIdx + 1, str.charCodeAt(strIdx));\n        if (treeIdx < 0) break;\n        current = decodeTree[treeIdx];\n        const masked = current & BinTrieFlags.VALUE_LENGTH;\n        // If the branch is a value, store it and continue\n        if (masked) {\n          // If we have a legacy entity while parsing strictly, just skip the number of bytes\n          if (!strict || str.charCodeAt(strIdx) === CharCodes.SEMI) {\n            resultIdx = treeIdx;\n            excess = 0;\n          }\n          // The mask is the number of bytes of the value, including the current byte.\n          const valueLength = (masked >> 14) - 1;\n          if (valueLength === 0) break;\n          treeIdx += valueLength;\n        }\n      }\n      if (resultIdx !== 0) {\n        const valueLength = (decodeTree[resultIdx] & BinTrieFlags.VALUE_LENGTH) >> 14;\n        ret += valueLength === 1 ? String.fromCharCode(decodeTree[resultIdx] & ~BinTrieFlags.VALUE_LENGTH) : valueLength === 2 ? String.fromCharCode(decodeTree[resultIdx + 1]) : String.fromCharCode(decodeTree[resultIdx + 1], decodeTree[resultIdx + 2]);\n        lastIdx = strIdx - excess + 1;\n      }\n    }\n    return ret + str.slice(lastIdx);\n  };\n}\nexport function determineBranch(decodeTree, current, nodeIdx, char) {\n  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;\n  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;\n  // Case 1: Single branch encoded in jump offset\n  if (branchCount === 0) {\n    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;\n  }\n  // Case 2: Multiple branches encoded in jump table\n  if (jumpOffset) {\n    const value = char - jumpOffset;\n    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;\n  }\n  // Case 3: Multiple branches encoded in dictionary\n  // Binary search for the character.\n  let lo = nodeIdx;\n  let hi = lo + branchCount - 1;\n  while (lo <= hi) {\n    const mid = lo + hi >>> 1;\n    const midVal = decodeTree[mid];\n    if (midVal < char) {\n      lo = mid + 1;\n    } else if (midVal > char) {\n      hi = mid - 1;\n    } else {\n      return decodeTree[mid + branchCount];\n    }\n  }\n  return -1;\n}\nconst htmlDecoder = getDecoder(htmlDecodeTree);\nconst xmlDecoder = getDecoder(xmlDecodeTree);\n/**\n * Decodes an HTML string, allowing for entities not terminated by a semi-colon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nexport function decodeHTML(str) {\n  return htmlDecoder(str, false);\n}\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semi-colon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nexport function decodeHTMLStrict(str) {\n  return htmlDecoder(str, true);\n}\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semi-colon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nexport function decodeXML(str) {\n  return xmlDecoder(str, true);\n}","map":{"version":3,"sources":["decode.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/entities/867ac709ba482a56a98b7c35f49ca833c74dc193/src/","sourcesContent":["import htmlDecodeTree from \"./generated/decode-data-html.js\";\nimport xmlDecodeTree from \"./generated/decode-data-xml.js\";\nimport decodeCodePoint from \"./decode_codepoint.js\";\n// Re-export for use by eg. htmlparser2\nexport { htmlDecodeTree, xmlDecodeTree, decodeCodePoint };\nexport { replaceCodePoint, fromCodePoint } from \"./decode_codepoint.js\";\nvar CharCodes;\n(function (CharCodes) {\n    CharCodes[CharCodes[\"NUM\"] = 35] = \"NUM\";\n    CharCodes[CharCodes[\"SEMI\"] = 59] = \"SEMI\";\n    CharCodes[CharCodes[\"ZERO\"] = 48] = \"ZERO\";\n    CharCodes[CharCodes[\"NINE\"] = 57] = \"NINE\";\n    CharCodes[CharCodes[\"LOWER_A\"] = 97] = \"LOWER_A\";\n    CharCodes[CharCodes[\"LOWER_F\"] = 102] = \"LOWER_F\";\n    CharCodes[CharCodes[\"LOWER_X\"] = 120] = \"LOWER_X\";\n    /** Bit that needs to be set to convert an upper case ASCII character to lower case */\n    CharCodes[CharCodes[\"To_LOWER_BIT\"] = 32] = \"To_LOWER_BIT\";\n})(CharCodes || (CharCodes = {}));\nexport var BinTrieFlags;\n(function (BinTrieFlags) {\n    BinTrieFlags[BinTrieFlags[\"VALUE_LENGTH\"] = 49152] = \"VALUE_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"BRANCH_LENGTH\"] = 16256] = \"BRANCH_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"JUMP_TABLE\"] = 127] = \"JUMP_TABLE\";\n})(BinTrieFlags || (BinTrieFlags = {}));\nfunction getDecoder(decodeTree) {\n    return function decodeHTMLBinary(str, strict) {\n        let ret = \"\";\n        let lastIdx = 0;\n        let strIdx = 0;\n        while ((strIdx = str.indexOf(\"&\", strIdx)) >= 0) {\n            ret += str.slice(lastIdx, strIdx);\n            lastIdx = strIdx;\n            // Skip the \"&\"\n            strIdx += 1;\n            // If we have a numeric entity, handle this separately.\n            if (str.charCodeAt(strIdx) === CharCodes.NUM) {\n                // Skip the leading \"&#\". For hex entities, also skip the leading \"x\".\n                let start = strIdx + 1;\n                let base = 10;\n                let cp = str.charCodeAt(start);\n                if ((cp | CharCodes.To_LOWER_BIT) === CharCodes.LOWER_X) {\n                    base = 16;\n                    strIdx += 1;\n                    start += 1;\n                }\n                do\n                    cp = str.charCodeAt(++strIdx);\n                while ((cp >= CharCodes.ZERO && cp <= CharCodes.NINE) ||\n                    (base === 16 &&\n                        (cp | CharCodes.To_LOWER_BIT) >= CharCodes.LOWER_A &&\n                        (cp | CharCodes.To_LOWER_BIT) <= CharCodes.LOWER_F));\n                if (start !== strIdx) {\n                    const entity = str.substring(start, strIdx);\n                    const parsed = parseInt(entity, base);\n                    if (str.charCodeAt(strIdx) === CharCodes.SEMI) {\n                        strIdx += 1;\n                    }\n                    else if (strict) {\n                        continue;\n                    }\n                    ret += decodeCodePoint(parsed);\n                    lastIdx = strIdx;\n                }\n                continue;\n            }\n            let resultIdx = 0;\n            let excess = 1;\n            let treeIdx = 0;\n            let current = decodeTree[treeIdx];\n            for (; strIdx < str.length; strIdx++, excess++) {\n                treeIdx = determineBranch(decodeTree, current, treeIdx + 1, str.charCodeAt(strIdx));\n                if (treeIdx < 0)\n                    break;\n                current = decodeTree[treeIdx];\n                const masked = current & BinTrieFlags.VALUE_LENGTH;\n                // If the branch is a value, store it and continue\n                if (masked) {\n                    // If we have a legacy entity while parsing strictly, just skip the number of bytes\n                    if (!strict || str.charCodeAt(strIdx) === CharCodes.SEMI) {\n                        resultIdx = treeIdx;\n                        excess = 0;\n                    }\n                    // The mask is the number of bytes of the value, including the current byte.\n                    const valueLength = (masked >> 14) - 1;\n                    if (valueLength === 0)\n                        break;\n                    treeIdx += valueLength;\n                }\n            }\n            if (resultIdx !== 0) {\n                const valueLength = (decodeTree[resultIdx] & BinTrieFlags.VALUE_LENGTH) >> 14;\n                ret +=\n                    valueLength === 1\n                        ? String.fromCharCode(decodeTree[resultIdx] & ~BinTrieFlags.VALUE_LENGTH)\n                        : valueLength === 2\n                            ? String.fromCharCode(decodeTree[resultIdx + 1])\n                            : String.fromCharCode(decodeTree[resultIdx + 1], decodeTree[resultIdx + 2]);\n                lastIdx = strIdx - excess + 1;\n            }\n        }\n        return ret + str.slice(lastIdx);\n    };\n}\nexport function determineBranch(decodeTree, current, nodeIdx, char) {\n    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;\n    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;\n    // Case 1: Single branch encoded in jump offset\n    if (branchCount === 0) {\n        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;\n    }\n    // Case 2: Multiple branches encoded in jump table\n    if (jumpOffset) {\n        const value = char - jumpOffset;\n        return value < 0 || value >= branchCount\n            ? -1\n            : decodeTree[nodeIdx + value] - 1;\n    }\n    // Case 3: Multiple branches encoded in dictionary\n    // Binary search for the character.\n    let lo = nodeIdx;\n    let hi = lo + branchCount - 1;\n    while (lo <= hi) {\n        const mid = (lo + hi) >>> 1;\n        const midVal = decodeTree[mid];\n        if (midVal < char) {\n            lo = mid + 1;\n        }\n        else if (midVal > char) {\n            hi = mid - 1;\n        }\n        else {\n            return decodeTree[mid + branchCount];\n        }\n    }\n    return -1;\n}\nconst htmlDecoder = getDecoder(htmlDecodeTree);\nconst xmlDecoder = getDecoder(xmlDecodeTree);\n/**\n * Decodes an HTML string, allowing for entities not terminated by a semi-colon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nexport function decodeHTML(str) {\n    return htmlDecoder(str, false);\n}\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semi-colon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nexport function decodeHTMLStrict(str) {\n    return htmlDecoder(str, true);\n}\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semi-colon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nexport function decodeXML(str) {\n    return xmlDecoder(str, true);\n}\n//# sourceMappingURL=decode.js.map"]},"metadata":{},"sourceType":"module"}