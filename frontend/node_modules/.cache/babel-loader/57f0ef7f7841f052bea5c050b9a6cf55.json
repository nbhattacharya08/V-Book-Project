{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;\nexports.xmlReplacer = /[\"&'<>$\\x80-\\uFFFF]/g;\nvar xmlCodeMap = new Map([[34, \"&quot;\"], [38, \"&amp;\"], [39, \"&apos;\"], [60, \"&lt;\"], [62, \"&gt;\"]]);\n// For compatibility with node < 4, we wrap `codePointAt`\nexports.getCodePoint =\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null ? function (str, index) {\n  return str.codePointAt(index);\n} :\n// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\nfunction (c, index) {\n  return (c.charCodeAt(index) & 0xfc00) === 0xd800 ? (c.charCodeAt(index) - 0xd800) * 0x400 + c.charCodeAt(index + 1) - 0xdc00 + 0x10000 : c.charCodeAt(index);\n};\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nfunction encodeXML(str) {\n  var ret = \"\";\n  var lastIdx = 0;\n  var match;\n  while ((match = exports.xmlReplacer.exec(str)) !== null) {\n    var i = match.index;\n    var char = str.charCodeAt(i);\n    var next = xmlCodeMap.get(char);\n    if (next !== undefined) {\n      ret += str.substring(lastIdx, i) + next;\n      lastIdx = i + 1;\n    } else {\n      ret += \"\".concat(str.substring(lastIdx, i), \"&#x\").concat((0, exports.getCodePoint)(str, i).toString(16), \";\");\n      // Increase by 1 if we have a surrogate pair\n      lastIdx = exports.xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);\n    }\n  }\n  return ret + str.substr(lastIdx);\n}\nexports.encodeXML = encodeXML;\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nexports.escape = encodeXML;\nfunction getEscaper(regex, map) {\n  return function escape(data) {\n    var match;\n    var lastIdx = 0;\n    var result = \"\";\n    while (match = regex.exec(data)) {\n      if (lastIdx !== match.index) {\n        result += data.substring(lastIdx, match.index);\n      }\n      // We know that this chararcter will be in the map.\n      result += map.get(match[0].charCodeAt(0));\n      // Every match will be of length 1\n      lastIdx = match.index + 1;\n    }\n    return result + data.substring(lastIdx);\n  };\n}\n/**\n * Encodes all characters not valid in XML documents using XML entities.\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nexports.escapeUTF8 = getEscaper(/[&<>'\"]/g, xmlCodeMap);\n/**\n * Encodes all characters that have to be escaped in HTML attributes,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexports.escapeAttribute = getEscaper(/[\"&\\u00A0]/g, new Map([[34, \"&quot;\"], [38, \"&amp;\"], [160, \"&nbsp;\"]]));\n/**\n * Encodes all characters that have to be escaped in HTML text,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexports.escapeText = getEscaper(/[&<>\\u00A0]/g, new Map([[38, \"&amp;\"], [60, \"&lt;\"], [62, \"&gt;\"], [160, \"&nbsp;\"]]));","map":{"version":3,"sources":["escape.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/entities/867ac709ba482a56a98b7c35f49ca833c74dc193/src/","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;\nexports.xmlReplacer = /[\"&'<>$\\x80-\\uFFFF]/g;\nvar xmlCodeMap = new Map([\n    [34, \"&quot;\"],\n    [38, \"&amp;\"],\n    [39, \"&apos;\"],\n    [60, \"&lt;\"],\n    [62, \"&gt;\"],\n]);\n// For compatibility with node < 4, we wrap `codePointAt`\nexports.getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? function (str, index) { return str.codePointAt(index); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c, index) {\n            return (c.charCodeAt(index) & 0xfc00) === 0xd800\n                ? (c.charCodeAt(index) - 0xd800) * 0x400 +\n                    c.charCodeAt(index + 1) -\n                    0xdc00 +\n                    0x10000\n                : c.charCodeAt(index);\n        };\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nfunction encodeXML(str) {\n    var ret = \"\";\n    var lastIdx = 0;\n    var match;\n    while ((match = exports.xmlReplacer.exec(str)) !== null) {\n        var i = match.index;\n        var char = str.charCodeAt(i);\n        var next = xmlCodeMap.get(char);\n        if (next !== undefined) {\n            ret += str.substring(lastIdx, i) + next;\n            lastIdx = i + 1;\n        }\n        else {\n            ret += \"\".concat(str.substring(lastIdx, i), \"&#x\").concat((0, exports.getCodePoint)(str, i).toString(16), \";\");\n            // Increase by 1 if we have a surrogate pair\n            lastIdx = exports.xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);\n        }\n    }\n    return ret + str.substr(lastIdx);\n}\nexports.encodeXML = encodeXML;\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nexports.escape = encodeXML;\nfunction getEscaper(regex, map) {\n    return function escape(data) {\n        var match;\n        var lastIdx = 0;\n        var result = \"\";\n        while ((match = regex.exec(data))) {\n            if (lastIdx !== match.index) {\n                result += data.substring(lastIdx, match.index);\n            }\n            // We know that this chararcter will be in the map.\n            result += map.get(match[0].charCodeAt(0));\n            // Every match will be of length 1\n            lastIdx = match.index + 1;\n        }\n        return result + data.substring(lastIdx);\n    };\n}\n/**\n * Encodes all characters not valid in XML documents using XML entities.\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nexports.escapeUTF8 = getEscaper(/[&<>'\"]/g, xmlCodeMap);\n/**\n * Encodes all characters that have to be escaped in HTML attributes,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexports.escapeAttribute = getEscaper(/[\"&\\u00A0]/g, new Map([\n    [34, \"&quot;\"],\n    [38, \"&amp;\"],\n    [160, \"&nbsp;\"],\n]));\n/**\n * Encodes all characters that have to be escaped in HTML text,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexports.escapeText = getEscaper(/[&<>\\u00A0]/g, new Map([\n    [38, \"&amp;\"],\n    [60, \"&lt;\"],\n    [62, \"&gt;\"],\n    [160, \"&nbsp;\"],\n]));\n//# sourceMappingURL=escape.js.map"]},"metadata":{},"sourceType":"script"}