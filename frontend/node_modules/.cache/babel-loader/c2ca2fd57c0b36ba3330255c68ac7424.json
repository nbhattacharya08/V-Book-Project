{"ast":null,"code":"/**\n * Methods for getting and modifying attributes.\n *\n * @module cheerio/attributes\n */\nimport { text } from '../static.js';\nimport { isTag, domEach, camelCase, cssCase } from '../utils.js';\nimport { innerText, textContent } from 'domutils';\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst rspace = /\\s+/;\nconst dataAttrPrefix = 'data-';\n/*\n * Lookup table for coercing string data-* attributes to their corresponding\n * JavaScript primitives\n */\nconst primitives = {\n  null: null,\n  true: true,\n  false: false\n};\n// Attributes that are booleans\nconst rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;\n// Matches strings that look like JSON objects or arrays\nconst rbrace = /^{[^]*}$|^\\[[^]*]$/;\nfunction getAttr(elem, name, xmlMode) {\n  var _a;\n  if (!elem || !isTag(elem)) return undefined;\n  (_a = elem.attribs) !== null && _a !== void 0 ? _a : elem.attribs = {};\n  // Return the entire attribs object if no attribute specified\n  if (!name) {\n    return elem.attribs;\n  }\n  if (hasOwn.call(elem.attribs, name)) {\n    // Get the (decoded) attribute\n    return !xmlMode && rboolean.test(name) ? name : elem.attribs[name];\n  }\n  // Mimic the DOM and return text content as value for `option's`\n  if (elem.name === 'option' && name === 'value') {\n    return text(elem.children);\n  }\n  // Mimic DOM with default value for radios/checkboxes\n  if (elem.name === 'input' && (elem.attribs['type'] === 'radio' || elem.attribs['type'] === 'checkbox') && name === 'value') {\n    return 'on';\n  }\n  return undefined;\n}\n/**\n * Sets the value of an attribute. The attribute will be deleted if the value is `null`.\n *\n * @private\n * @param el - The element to set the attribute on.\n * @param name - The attribute's name.\n * @param value - The attribute's value.\n */\nfunction setAttr(el, name, value) {\n  if (value === null) {\n    removeAttribute(el, name);\n  } else {\n    el.attribs[name] = `${value}`;\n  }\n}\nexport function attr(name, value) {\n  // Set the value (with attr map support)\n  if (typeof name === 'object' || value !== undefined) {\n    if (typeof value === 'function') {\n      if (typeof name !== 'string') {\n        {\n          throw new Error('Bad combination of arguments.');\n        }\n      }\n      return domEach(this, (el, i) => {\n        if (isTag(el)) setAttr(el, name, value.call(el, i, el.attribs[name]));\n      });\n    }\n    return domEach(this, el => {\n      if (!isTag(el)) return;\n      if (typeof name === 'object') {\n        Object.keys(name).forEach(objName => {\n          const objValue = name[objName];\n          setAttr(el, objName, objValue);\n        });\n      } else {\n        setAttr(el, name, value);\n      }\n    });\n  }\n  return arguments.length > 1 ? this : getAttr(this[0], name, this.options.xmlMode);\n}\n/**\n * Gets a node's prop.\n *\n * @private\n * @category Attributes\n * @param el - Element to get the prop of.\n * @param name - Name of the prop.\n * @returns The prop's value.\n */\nfunction getProp(el, name, xmlMode) {\n  return name in el ?\n  // @ts-expect-error TS doesn't like us accessing the value directly here.\n  el[name] : !xmlMode && rboolean.test(name) ? getAttr(el, name, false) !== undefined : getAttr(el, name, xmlMode);\n}\n/**\n * Sets the value of a prop.\n *\n * @private\n * @param el - The element to set the prop on.\n * @param name - The prop's name.\n * @param value - The prop's value.\n */\nfunction setProp(el, name, value, xmlMode) {\n  if (name in el) {\n    // @ts-expect-error Overriding value\n    el[name] = value;\n  } else {\n    setAttr(el, name, !xmlMode && rboolean.test(name) ? value ? '' : null : `${value}`);\n  }\n}\nexport function prop(name, value) {\n  var _a;\n  if (typeof name === 'string' && value === undefined) {\n    const el = this[0];\n    if (!el || !isTag(el)) return undefined;\n    switch (name) {\n      case 'style':\n        {\n          const property = this.css();\n          const keys = Object.keys(property);\n          keys.forEach((p, i) => {\n            property[i] = p;\n          });\n          property.length = keys.length;\n          return property;\n        }\n      case 'tagName':\n      case 'nodeName':\n        {\n          return el.name.toUpperCase();\n        }\n      case 'href':\n      case 'src':\n        {\n          const prop = (_a = el.attribs) === null || _a === void 0 ? void 0 : _a[name];\n          /* eslint-disable node/no-unsupported-features/node-builtins */\n          if (typeof URL !== 'undefined' && (name === 'href' && (el.tagName === 'a' || el.name === 'link') || name === 'src' && (el.tagName === 'img' || el.tagName === 'iframe' || el.tagName === 'audio' || el.tagName === 'video' || el.tagName === 'source')) && prop !== undefined && this.options.baseURI) {\n            return new URL(prop, this.options.baseURI).href;\n          }\n          /* eslint-enable node/no-unsupported-features/node-builtins */\n          return prop;\n        }\n      case 'innerText':\n        {\n          return innerText(el);\n        }\n      case 'textContent':\n        {\n          return textContent(el);\n        }\n      case 'outerHTML':\n        return this.clone().wrap('<container />').parent().html();\n      case 'innerHTML':\n        return this.html();\n      default:\n        return getProp(el, name, this.options.xmlMode);\n    }\n  }\n  if (typeof name === 'object' || value !== undefined) {\n    if (typeof value === 'function') {\n      if (typeof name === 'object') {\n        throw new Error('Bad combination of arguments.');\n      }\n      return domEach(this, (el, i) => {\n        if (isTag(el)) {\n          setProp(el, name, value.call(el, i, getProp(el, name, this.options.xmlMode)), this.options.xmlMode);\n        }\n      });\n    }\n    return domEach(this, el => {\n      if (!isTag(el)) return;\n      if (typeof name === 'object') {\n        Object.keys(name).forEach(key => {\n          const val = name[key];\n          setProp(el, key, val, this.options.xmlMode);\n        });\n      } else {\n        setProp(el, name, value, this.options.xmlMode);\n      }\n    });\n  }\n  return undefined;\n}\n/**\n * Sets the value of a data attribute.\n *\n * @private\n * @param el - The element to set the data attribute on.\n * @param name - The data attribute's name.\n * @param value - The data attribute's value.\n */\nfunction setData(el, name, value) {\n  var _a;\n  const elem = el;\n  (_a = elem.data) !== null && _a !== void 0 ? _a : elem.data = {};\n  if (typeof name === 'object') Object.assign(elem.data, name);else if (typeof name === 'string' && value !== undefined) {\n    elem.data[name] = value;\n  }\n}\n/**\n * Read the specified attribute from the equivalent HTML5 `data-*` attribute,\n * and (if present) cache the value in the node's internal data store. If no\n * attribute name is specified, read _all_ HTML5 `data-*` attributes in this manner.\n *\n * @private\n * @category Attributes\n * @param el - Element to get the data attribute of.\n * @param name - Name of the data attribute.\n * @returns The data attribute's value, or a map with all of the data attributes.\n */\nfunction readData(el, name) {\n  let domNames;\n  let jsNames;\n  let value;\n  if (name == null) {\n    domNames = Object.keys(el.attribs).filter(attrName => attrName.startsWith(dataAttrPrefix));\n    jsNames = domNames.map(domName => camelCase(domName.slice(dataAttrPrefix.length)));\n  } else {\n    domNames = [dataAttrPrefix + cssCase(name)];\n    jsNames = [name];\n  }\n  for (let idx = 0; idx < domNames.length; ++idx) {\n    const domName = domNames[idx];\n    const jsName = jsNames[idx];\n    if (hasOwn.call(el.attribs, domName) && !hasOwn.call(el.data, jsName)) {\n      value = el.attribs[domName];\n      if (hasOwn.call(primitives, value)) {\n        value = primitives[value];\n      } else if (value === String(Number(value))) {\n        value = Number(value);\n      } else if (rbrace.test(value)) {\n        try {\n          value = JSON.parse(value);\n        } catch (e) {\n          /* Ignore */\n        }\n      }\n      el.data[jsName] = value;\n    }\n  }\n  return name == null ? el.data : value;\n}\nexport function data(name, value) {\n  var _a;\n  const elem = this[0];\n  if (!elem || !isTag(elem)) return;\n  const dataEl = elem;\n  (_a = dataEl.data) !== null && _a !== void 0 ? _a : dataEl.data = {};\n  // Return the entire data object if no data specified\n  if (!name) {\n    return readData(dataEl);\n  }\n  // Set the value (with attr map support)\n  if (typeof name === 'object' || value !== undefined) {\n    domEach(this, el => {\n      if (isTag(el)) {\n        if (typeof name === 'object') setData(el, name);else setData(el, name, value);\n      }\n    });\n    return this;\n  }\n  if (hasOwn.call(dataEl.data, name)) {\n    return dataEl.data[name];\n  }\n  return readData(dataEl, name);\n}\nexport function val(value) {\n  const querying = arguments.length === 0;\n  const element = this[0];\n  if (!element || !isTag(element)) return querying ? undefined : this;\n  switch (element.name) {\n    case 'textarea':\n      return this.text(value);\n    case 'select':\n      {\n        const option = this.find('option:selected');\n        if (!querying) {\n          if (this.attr('multiple') == null && typeof value === 'object') {\n            return this;\n          }\n          this.find('option').removeAttr('selected');\n          const values = typeof value !== 'object' ? [value] : value;\n          for (let i = 0; i < values.length; i++) {\n            this.find(`option[value=\"${values[i]}\"]`).attr('selected', '');\n          }\n          return this;\n        }\n        return this.attr('multiple') ? option.toArray().map(el => text(el.children)) : option.attr('value');\n      }\n    case 'input':\n    case 'option':\n      return querying ? this.attr('value') : this.attr('value', value);\n  }\n  return undefined;\n}\n/**\n * Remove an attribute.\n *\n * @private\n * @param elem - Node to remove attribute from.\n * @param name - Name of the attribute to remove.\n */\nfunction removeAttribute(elem, name) {\n  if (!elem.attribs || !hasOwn.call(elem.attribs, name)) return;\n  delete elem.attribs[name];\n}\n/**\n * Splits a space-separated list of names to individual names.\n *\n * @category Attributes\n * @param names - Names to split.\n * @returns - Split names.\n */\nfunction splitNames(names) {\n  return names ? names.trim().split(rspace) : [];\n}\n/**\n * Method for removing attributes by `name`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').removeAttr('class').html();\n * //=> <li>Pear</li>\n *\n * $('.apple').attr('id', 'favorite');\n * $('.apple').removeAttr('id class').html();\n * //=> <li>Apple</li>\n * ```\n *\n * @param name - Name of the attribute.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/removeAttr/}\n */\nexport function removeAttr(name) {\n  const attrNames = splitNames(name);\n  for (let i = 0; i < attrNames.length; i++) {\n    domEach(this, elem => {\n      if (isTag(elem)) removeAttribute(elem, attrNames[i]);\n    });\n  }\n  return this;\n}\n/**\n * Check to see if _any_ of the matched elements have the given `className`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').hasClass('pear');\n * //=> true\n *\n * $('apple').hasClass('fruit');\n * //=> false\n *\n * $('li').hasClass('pear');\n * //=> true\n * ```\n *\n * @param className - Name of the class.\n * @returns Indicates if an element has the given `className`.\n * @see {@link https://api.jquery.com/hasClass/}\n */\nexport function hasClass(className) {\n  return this.toArray().some(elem => {\n    const clazz = isTag(elem) && elem.attribs['class'];\n    let idx = -1;\n    if (clazz && className.length) {\n      while ((idx = clazz.indexOf(className, idx + 1)) > -1) {\n        const end = idx + className.length;\n        if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end === clazz.length || rspace.test(clazz[end]))) {\n          return true;\n        }\n      }\n    }\n    return false;\n  });\n}\n/**\n * Adds class(es) to all of the matched elements. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').addClass('fruit').html();\n * //=> <li class=\"pear fruit\">Pear</li>\n *\n * $('.apple').addClass('fruit red').html();\n * //=> <li class=\"apple fruit red\">Apple</li>\n * ```\n *\n * @param value - Name of new class.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/addClass/}\n */\nexport function addClass(value) {\n  // Support functions\n  if (typeof value === 'function') {\n    return domEach(this, (el, i) => {\n      if (isTag(el)) {\n        const className = el.attribs['class'] || '';\n        addClass.call([el], value.call(el, i, className));\n      }\n    });\n  }\n  // Return if no value or not a string or function\n  if (!value || typeof value !== 'string') return this;\n  const classNames = value.split(rspace);\n  const numElements = this.length;\n  for (let i = 0; i < numElements; i++) {\n    const el = this[i];\n    // If selected element isn't a tag, move on\n    if (!isTag(el)) continue;\n    // If we don't already have classes — always set xmlMode to false here, as it doesn't matter for classes\n    const className = getAttr(el, 'class', false);\n    if (!className) {\n      setAttr(el, 'class', classNames.join(' ').trim());\n    } else {\n      let setClass = ` ${className} `;\n      // Check if class already exists\n      for (let j = 0; j < classNames.length; j++) {\n        const appendClass = `${classNames[j]} `;\n        if (!setClass.includes(` ${appendClass}`)) setClass += appendClass;\n      }\n      setAttr(el, 'class', setClass.trim());\n    }\n  }\n  return this;\n}\n/**\n * Removes one or more space-separated classes from the selected elements. If no\n * `className` is defined, all classes will be removed. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').removeClass('pear').html();\n * //=> <li class=\"\">Pear</li>\n *\n * $('.apple').addClass('red').removeClass().html();\n * //=> <li class=\"\">Apple</li>\n * ```\n *\n * @param name - Name of the class. If not specified, removes all elements.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/removeClass/}\n */\nexport function removeClass(name) {\n  // Handle if value is a function\n  if (typeof name === 'function') {\n    return domEach(this, (el, i) => {\n      if (isTag(el)) {\n        removeClass.call([el], name.call(el, i, el.attribs['class'] || ''));\n      }\n    });\n  }\n  const classes = splitNames(name);\n  const numClasses = classes.length;\n  const removeAll = arguments.length === 0;\n  return domEach(this, el => {\n    if (!isTag(el)) return;\n    if (removeAll) {\n      // Short circuit the remove all case as this is the nice one\n      el.attribs['class'] = '';\n    } else {\n      const elClasses = splitNames(el.attribs['class']);\n      let changed = false;\n      for (let j = 0; j < numClasses; j++) {\n        const index = elClasses.indexOf(classes[j]);\n        if (index >= 0) {\n          elClasses.splice(index, 1);\n          changed = true;\n          /*\n           * We have to do another pass to ensure that there are not duplicate\n           * classes listed\n           */\n          j--;\n        }\n      }\n      if (changed) {\n        el.attribs['class'] = elClasses.join(' ');\n      }\n    }\n  });\n}\n/**\n * Add or remove class(es) from the matched elements, depending on either the\n * class's presence or the value of the switch argument. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.apple.green').toggleClass('fruit green red').html();\n * //=> <li class=\"apple fruit red\">Apple</li>\n *\n * $('.apple.green').toggleClass('fruit green red', true).html();\n * //=> <li class=\"apple green fruit red\">Apple</li>\n * ```\n *\n * @param value - Name of the class. Can also be a function.\n * @param stateVal - If specified the state of the class.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/toggleClass/}\n */\nexport function toggleClass(value, stateVal) {\n  // Support functions\n  if (typeof value === 'function') {\n    return domEach(this, (el, i) => {\n      if (isTag(el)) {\n        toggleClass.call([el], value.call(el, i, el.attribs['class'] || '', stateVal), stateVal);\n      }\n    });\n  }\n  // Return if no value or not a string or function\n  if (!value || typeof value !== 'string') return this;\n  const classNames = value.split(rspace);\n  const numClasses = classNames.length;\n  const state = typeof stateVal === 'boolean' ? stateVal ? 1 : -1 : 0;\n  const numElements = this.length;\n  for (let i = 0; i < numElements; i++) {\n    const el = this[i];\n    // If selected element isn't a tag, move on\n    if (!isTag(el)) continue;\n    const elementClasses = splitNames(el.attribs['class']);\n    // Check if class already exists\n    for (let j = 0; j < numClasses; j++) {\n      // Check if the class name is currently defined\n      const index = elementClasses.indexOf(classNames[j]);\n      // Add if stateValue === true or we are toggling and there is no value\n      if (state >= 0 && index < 0) {\n        elementClasses.push(classNames[j]);\n      } else if (state <= 0 && index >= 0) {\n        // Otherwise remove but only if the item exists\n        elementClasses.splice(index, 1);\n      }\n    }\n    el.attribs['class'] = elementClasses.join(' ');\n  }\n  return this;\n}","map":{"version":3,"sources":["api/attributes.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/cheeriojs/cheerio/d1cbc66d53392ce8bf6cd0068f675836372d2bf3/src/","sourcesContent":["/**\n * Methods for getting and modifying attributes.\n *\n * @module cheerio/attributes\n */\nimport { text } from '../static.js';\nimport { isTag, domEach, camelCase, cssCase } from '../utils.js';\nimport { innerText, textContent } from 'domutils';\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst rspace = /\\s+/;\nconst dataAttrPrefix = 'data-';\n/*\n * Lookup table for coercing string data-* attributes to their corresponding\n * JavaScript primitives\n */\nconst primitives = {\n    null: null,\n    true: true,\n    false: false,\n};\n// Attributes that are booleans\nconst rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;\n// Matches strings that look like JSON objects or arrays\nconst rbrace = /^{[^]*}$|^\\[[^]*]$/;\nfunction getAttr(elem, name, xmlMode) {\n    var _a;\n    if (!elem || !isTag(elem))\n        return undefined;\n    (_a = elem.attribs) !== null && _a !== void 0 ? _a : (elem.attribs = {});\n    // Return the entire attribs object if no attribute specified\n    if (!name) {\n        return elem.attribs;\n    }\n    if (hasOwn.call(elem.attribs, name)) {\n        // Get the (decoded) attribute\n        return !xmlMode && rboolean.test(name) ? name : elem.attribs[name];\n    }\n    // Mimic the DOM and return text content as value for `option's`\n    if (elem.name === 'option' && name === 'value') {\n        return text(elem.children);\n    }\n    // Mimic DOM with default value for radios/checkboxes\n    if (elem.name === 'input' &&\n        (elem.attribs['type'] === 'radio' || elem.attribs['type'] === 'checkbox') &&\n        name === 'value') {\n        return 'on';\n    }\n    return undefined;\n}\n/**\n * Sets the value of an attribute. The attribute will be deleted if the value is `null`.\n *\n * @private\n * @param el - The element to set the attribute on.\n * @param name - The attribute's name.\n * @param value - The attribute's value.\n */\nfunction setAttr(el, name, value) {\n    if (value === null) {\n        removeAttribute(el, name);\n    }\n    else {\n        el.attribs[name] = `${value}`;\n    }\n}\nexport function attr(name, value) {\n    // Set the value (with attr map support)\n    if (typeof name === 'object' || value !== undefined) {\n        if (typeof value === 'function') {\n            if (typeof name !== 'string') {\n                {\n                    throw new Error('Bad combination of arguments.');\n                }\n            }\n            return domEach(this, (el, i) => {\n                if (isTag(el))\n                    setAttr(el, name, value.call(el, i, el.attribs[name]));\n            });\n        }\n        return domEach(this, (el) => {\n            if (!isTag(el))\n                return;\n            if (typeof name === 'object') {\n                Object.keys(name).forEach((objName) => {\n                    const objValue = name[objName];\n                    setAttr(el, objName, objValue);\n                });\n            }\n            else {\n                setAttr(el, name, value);\n            }\n        });\n    }\n    return arguments.length > 1\n        ? this\n        : getAttr(this[0], name, this.options.xmlMode);\n}\n/**\n * Gets a node's prop.\n *\n * @private\n * @category Attributes\n * @param el - Element to get the prop of.\n * @param name - Name of the prop.\n * @returns The prop's value.\n */\nfunction getProp(el, name, xmlMode) {\n    return name in el\n        ? // @ts-expect-error TS doesn't like us accessing the value directly here.\n            el[name]\n        : !xmlMode && rboolean.test(name)\n            ? getAttr(el, name, false) !== undefined\n            : getAttr(el, name, xmlMode);\n}\n/**\n * Sets the value of a prop.\n *\n * @private\n * @param el - The element to set the prop on.\n * @param name - The prop's name.\n * @param value - The prop's value.\n */\nfunction setProp(el, name, value, xmlMode) {\n    if (name in el) {\n        // @ts-expect-error Overriding value\n        el[name] = value;\n    }\n    else {\n        setAttr(el, name, !xmlMode && rboolean.test(name) ? (value ? '' : null) : `${value}`);\n    }\n}\nexport function prop(name, value) {\n    var _a;\n    if (typeof name === 'string' && value === undefined) {\n        const el = this[0];\n        if (!el || !isTag(el))\n            return undefined;\n        switch (name) {\n            case 'style': {\n                const property = this.css();\n                const keys = Object.keys(property);\n                keys.forEach((p, i) => {\n                    property[i] = p;\n                });\n                property.length = keys.length;\n                return property;\n            }\n            case 'tagName':\n            case 'nodeName': {\n                return el.name.toUpperCase();\n            }\n            case 'href':\n            case 'src': {\n                const prop = (_a = el.attribs) === null || _a === void 0 ? void 0 : _a[name];\n                /* eslint-disable node/no-unsupported-features/node-builtins */\n                if (typeof URL !== 'undefined' &&\n                    ((name === 'href' && (el.tagName === 'a' || el.name === 'link')) ||\n                        (name === 'src' &&\n                            (el.tagName === 'img' ||\n                                el.tagName === 'iframe' ||\n                                el.tagName === 'audio' ||\n                                el.tagName === 'video' ||\n                                el.tagName === 'source'))) &&\n                    prop !== undefined &&\n                    this.options.baseURI) {\n                    return new URL(prop, this.options.baseURI).href;\n                }\n                /* eslint-enable node/no-unsupported-features/node-builtins */\n                return prop;\n            }\n            case 'innerText': {\n                return innerText(el);\n            }\n            case 'textContent': {\n                return textContent(el);\n            }\n            case 'outerHTML':\n                return this.clone().wrap('<container />').parent().html();\n            case 'innerHTML':\n                return this.html();\n            default:\n                return getProp(el, name, this.options.xmlMode);\n        }\n    }\n    if (typeof name === 'object' || value !== undefined) {\n        if (typeof value === 'function') {\n            if (typeof name === 'object') {\n                throw new Error('Bad combination of arguments.');\n            }\n            return domEach(this, (el, i) => {\n                if (isTag(el)) {\n                    setProp(el, name, value.call(el, i, getProp(el, name, this.options.xmlMode)), this.options.xmlMode);\n                }\n            });\n        }\n        return domEach(this, (el) => {\n            if (!isTag(el))\n                return;\n            if (typeof name === 'object') {\n                Object.keys(name).forEach((key) => {\n                    const val = name[key];\n                    setProp(el, key, val, this.options.xmlMode);\n                });\n            }\n            else {\n                setProp(el, name, value, this.options.xmlMode);\n            }\n        });\n    }\n    return undefined;\n}\n/**\n * Sets the value of a data attribute.\n *\n * @private\n * @param el - The element to set the data attribute on.\n * @param name - The data attribute's name.\n * @param value - The data attribute's value.\n */\nfunction setData(el, name, value) {\n    var _a;\n    const elem = el;\n    (_a = elem.data) !== null && _a !== void 0 ? _a : (elem.data = {});\n    if (typeof name === 'object')\n        Object.assign(elem.data, name);\n    else if (typeof name === 'string' && value !== undefined) {\n        elem.data[name] = value;\n    }\n}\n/**\n * Read the specified attribute from the equivalent HTML5 `data-*` attribute,\n * and (if present) cache the value in the node's internal data store. If no\n * attribute name is specified, read _all_ HTML5 `data-*` attributes in this manner.\n *\n * @private\n * @category Attributes\n * @param el - Element to get the data attribute of.\n * @param name - Name of the data attribute.\n * @returns The data attribute's value, or a map with all of the data attributes.\n */\nfunction readData(el, name) {\n    let domNames;\n    let jsNames;\n    let value;\n    if (name == null) {\n        domNames = Object.keys(el.attribs).filter((attrName) => attrName.startsWith(dataAttrPrefix));\n        jsNames = domNames.map((domName) => camelCase(domName.slice(dataAttrPrefix.length)));\n    }\n    else {\n        domNames = [dataAttrPrefix + cssCase(name)];\n        jsNames = [name];\n    }\n    for (let idx = 0; idx < domNames.length; ++idx) {\n        const domName = domNames[idx];\n        const jsName = jsNames[idx];\n        if (hasOwn.call(el.attribs, domName) &&\n            !hasOwn.call(el.data, jsName)) {\n            value = el.attribs[domName];\n            if (hasOwn.call(primitives, value)) {\n                value = primitives[value];\n            }\n            else if (value === String(Number(value))) {\n                value = Number(value);\n            }\n            else if (rbrace.test(value)) {\n                try {\n                    value = JSON.parse(value);\n                }\n                catch (e) {\n                    /* Ignore */\n                }\n            }\n            el.data[jsName] = value;\n        }\n    }\n    return name == null ? el.data : value;\n}\nexport function data(name, value) {\n    var _a;\n    const elem = this[0];\n    if (!elem || !isTag(elem))\n        return;\n    const dataEl = elem;\n    (_a = dataEl.data) !== null && _a !== void 0 ? _a : (dataEl.data = {});\n    // Return the entire data object if no data specified\n    if (!name) {\n        return readData(dataEl);\n    }\n    // Set the value (with attr map support)\n    if (typeof name === 'object' || value !== undefined) {\n        domEach(this, (el) => {\n            if (isTag(el)) {\n                if (typeof name === 'object')\n                    setData(el, name);\n                else\n                    setData(el, name, value);\n            }\n        });\n        return this;\n    }\n    if (hasOwn.call(dataEl.data, name)) {\n        return dataEl.data[name];\n    }\n    return readData(dataEl, name);\n}\nexport function val(value) {\n    const querying = arguments.length === 0;\n    const element = this[0];\n    if (!element || !isTag(element))\n        return querying ? undefined : this;\n    switch (element.name) {\n        case 'textarea':\n            return this.text(value);\n        case 'select': {\n            const option = this.find('option:selected');\n            if (!querying) {\n                if (this.attr('multiple') == null && typeof value === 'object') {\n                    return this;\n                }\n                this.find('option').removeAttr('selected');\n                const values = typeof value !== 'object' ? [value] : value;\n                for (let i = 0; i < values.length; i++) {\n                    this.find(`option[value=\"${values[i]}\"]`).attr('selected', '');\n                }\n                return this;\n            }\n            return this.attr('multiple')\n                ? option.toArray().map((el) => text(el.children))\n                : option.attr('value');\n        }\n        case 'input':\n        case 'option':\n            return querying\n                ? this.attr('value')\n                : this.attr('value', value);\n    }\n    return undefined;\n}\n/**\n * Remove an attribute.\n *\n * @private\n * @param elem - Node to remove attribute from.\n * @param name - Name of the attribute to remove.\n */\nfunction removeAttribute(elem, name) {\n    if (!elem.attribs || !hasOwn.call(elem.attribs, name))\n        return;\n    delete elem.attribs[name];\n}\n/**\n * Splits a space-separated list of names to individual names.\n *\n * @category Attributes\n * @param names - Names to split.\n * @returns - Split names.\n */\nfunction splitNames(names) {\n    return names ? names.trim().split(rspace) : [];\n}\n/**\n * Method for removing attributes by `name`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').removeAttr('class').html();\n * //=> <li>Pear</li>\n *\n * $('.apple').attr('id', 'favorite');\n * $('.apple').removeAttr('id class').html();\n * //=> <li>Apple</li>\n * ```\n *\n * @param name - Name of the attribute.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/removeAttr/}\n */\nexport function removeAttr(name) {\n    const attrNames = splitNames(name);\n    for (let i = 0; i < attrNames.length; i++) {\n        domEach(this, (elem) => {\n            if (isTag(elem))\n                removeAttribute(elem, attrNames[i]);\n        });\n    }\n    return this;\n}\n/**\n * Check to see if _any_ of the matched elements have the given `className`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').hasClass('pear');\n * //=> true\n *\n * $('apple').hasClass('fruit');\n * //=> false\n *\n * $('li').hasClass('pear');\n * //=> true\n * ```\n *\n * @param className - Name of the class.\n * @returns Indicates if an element has the given `className`.\n * @see {@link https://api.jquery.com/hasClass/}\n */\nexport function hasClass(className) {\n    return this.toArray().some((elem) => {\n        const clazz = isTag(elem) && elem.attribs['class'];\n        let idx = -1;\n        if (clazz && className.length) {\n            while ((idx = clazz.indexOf(className, idx + 1)) > -1) {\n                const end = idx + className.length;\n                if ((idx === 0 || rspace.test(clazz[idx - 1])) &&\n                    (end === clazz.length || rspace.test(clazz[end]))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    });\n}\n/**\n * Adds class(es) to all of the matched elements. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').addClass('fruit').html();\n * //=> <li class=\"pear fruit\">Pear</li>\n *\n * $('.apple').addClass('fruit red').html();\n * //=> <li class=\"apple fruit red\">Apple</li>\n * ```\n *\n * @param value - Name of new class.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/addClass/}\n */\nexport function addClass(value) {\n    // Support functions\n    if (typeof value === 'function') {\n        return domEach(this, (el, i) => {\n            if (isTag(el)) {\n                const className = el.attribs['class'] || '';\n                addClass.call([el], value.call(el, i, className));\n            }\n        });\n    }\n    // Return if no value or not a string or function\n    if (!value || typeof value !== 'string')\n        return this;\n    const classNames = value.split(rspace);\n    const numElements = this.length;\n    for (let i = 0; i < numElements; i++) {\n        const el = this[i];\n        // If selected element isn't a tag, move on\n        if (!isTag(el))\n            continue;\n        // If we don't already have classes — always set xmlMode to false here, as it doesn't matter for classes\n        const className = getAttr(el, 'class', false);\n        if (!className) {\n            setAttr(el, 'class', classNames.join(' ').trim());\n        }\n        else {\n            let setClass = ` ${className} `;\n            // Check if class already exists\n            for (let j = 0; j < classNames.length; j++) {\n                const appendClass = `${classNames[j]} `;\n                if (!setClass.includes(` ${appendClass}`))\n                    setClass += appendClass;\n            }\n            setAttr(el, 'class', setClass.trim());\n        }\n    }\n    return this;\n}\n/**\n * Removes one or more space-separated classes from the selected elements. If no\n * `className` is defined, all classes will be removed. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').removeClass('pear').html();\n * //=> <li class=\"\">Pear</li>\n *\n * $('.apple').addClass('red').removeClass().html();\n * //=> <li class=\"\">Apple</li>\n * ```\n *\n * @param name - Name of the class. If not specified, removes all elements.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/removeClass/}\n */\nexport function removeClass(name) {\n    // Handle if value is a function\n    if (typeof name === 'function') {\n        return domEach(this, (el, i) => {\n            if (isTag(el)) {\n                removeClass.call([el], name.call(el, i, el.attribs['class'] || ''));\n            }\n        });\n    }\n    const classes = splitNames(name);\n    const numClasses = classes.length;\n    const removeAll = arguments.length === 0;\n    return domEach(this, (el) => {\n        if (!isTag(el))\n            return;\n        if (removeAll) {\n            // Short circuit the remove all case as this is the nice one\n            el.attribs['class'] = '';\n        }\n        else {\n            const elClasses = splitNames(el.attribs['class']);\n            let changed = false;\n            for (let j = 0; j < numClasses; j++) {\n                const index = elClasses.indexOf(classes[j]);\n                if (index >= 0) {\n                    elClasses.splice(index, 1);\n                    changed = true;\n                    /*\n                     * We have to do another pass to ensure that there are not duplicate\n                     * classes listed\n                     */\n                    j--;\n                }\n            }\n            if (changed) {\n                el.attribs['class'] = elClasses.join(' ');\n            }\n        }\n    });\n}\n/**\n * Add or remove class(es) from the matched elements, depending on either the\n * class's presence or the value of the switch argument. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.apple.green').toggleClass('fruit green red').html();\n * //=> <li class=\"apple fruit red\">Apple</li>\n *\n * $('.apple.green').toggleClass('fruit green red', true).html();\n * //=> <li class=\"apple green fruit red\">Apple</li>\n * ```\n *\n * @param value - Name of the class. Can also be a function.\n * @param stateVal - If specified the state of the class.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/toggleClass/}\n */\nexport function toggleClass(value, stateVal) {\n    // Support functions\n    if (typeof value === 'function') {\n        return domEach(this, (el, i) => {\n            if (isTag(el)) {\n                toggleClass.call([el], value.call(el, i, el.attribs['class'] || '', stateVal), stateVal);\n            }\n        });\n    }\n    // Return if no value or not a string or function\n    if (!value || typeof value !== 'string')\n        return this;\n    const classNames = value.split(rspace);\n    const numClasses = classNames.length;\n    const state = typeof stateVal === 'boolean' ? (stateVal ? 1 : -1) : 0;\n    const numElements = this.length;\n    for (let i = 0; i < numElements; i++) {\n        const el = this[i];\n        // If selected element isn't a tag, move on\n        if (!isTag(el))\n            continue;\n        const elementClasses = splitNames(el.attribs['class']);\n        // Check if class already exists\n        for (let j = 0; j < numClasses; j++) {\n            // Check if the class name is currently defined\n            const index = elementClasses.indexOf(classNames[j]);\n            // Add if stateValue === true or we are toggling and there is no value\n            if (state >= 0 && index < 0) {\n                elementClasses.push(classNames[j]);\n            }\n            else if (state <= 0 && index >= 0) {\n                // Otherwise remove but only if the item exists\n                elementClasses.splice(index, 1);\n            }\n        }\n        el.attribs['class'] = elementClasses.join(' ');\n    }\n    return this;\n}\n//# sourceMappingURL=attributes.js.map"]},"metadata":{},"sourceType":"module"}