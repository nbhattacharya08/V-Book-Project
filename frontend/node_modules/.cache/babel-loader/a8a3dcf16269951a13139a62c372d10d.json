{"ast":null,"code":"import { parse } from \"css-what\";\nimport { filters } from \"./filters.js\";\nimport { pseudos, verifyPseudoArgs } from \"./pseudos.js\";\nimport { aliases } from \"./aliases.js\";\nimport { subselects } from \"./subselects.js\";\nexport { filters, pseudos, aliases };\nexport function compilePseudoSelector(next, selector, options, context, compileToken) {\n  var _a;\n  const {\n    name,\n    data\n  } = selector;\n  if (Array.isArray(data)) {\n    if (!(name in subselects)) {\n      throw new Error(`Unknown pseudo-class :${name}(${data})`);\n    }\n    return subselects[name](next, data, options, context, compileToken);\n  }\n  const userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];\n  const stringPseudo = typeof userPseudo === \"string\" ? userPseudo : aliases[name];\n  if (typeof stringPseudo === \"string\") {\n    if (data != null) {\n      throw new Error(`Pseudo ${name} doesn't have any arguments`);\n    }\n    // The alias has to be parsed here, to make sure options are respected.\n    const alias = parse(stringPseudo);\n    return subselects[\"is\"](next, alias, options, context, compileToken);\n  }\n  if (typeof userPseudo === \"function\") {\n    verifyPseudoArgs(userPseudo, name, data, 1);\n    return elem => userPseudo(elem, data) && next(elem);\n  }\n  if (name in filters) {\n    return filters[name](next, data, options, context);\n  }\n  if (name in pseudos) {\n    const pseudo = pseudos[name];\n    verifyPseudoArgs(pseudo, name, data, 2);\n    return elem => pseudo(elem, options, data) && next(elem);\n  }\n  throw new Error(`Unknown pseudo-class :${name}`);\n}","map":{"version":3,"sources":["pseudo-selectors/index.ts"],"names":[],"mappings":"AAeA,SAAS,KAAK,QAAwB,UAAU;AAChD,SAAS,OAAO,QAAQ,cAAc;AACtC,SAAS,OAAO,EAAE,gBAAgB,QAAQ,cAAc;AACxD,SAAS,OAAO,QAAQ,cAAc;AACtC,SAAS,UAAU,QAAQ,iBAAiB;AAE5C,SAAS,OAAO,EAAE,OAAO,EAAE,OAAO;AAElC,OAAM,SAAU,qBAAqB,CACjC,IAAgC,EAChC,QAAwB,EACxB,OAA2C,EAC3C,OAA2B,EAC3B,YAA6C,EAAA;;EAE7C,MAAM;IAAE,IAAI;IAAE;EAAI,CAAE,GAAG,QAAQ;EAE/B,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;IACrB,IAAI,EAAE,IAAI,IAAI,UAAU,CAAC,EAAE;MACvB,MAAM,IAAI,KAAK,CAAC,yBAAyB,IAAI,IAAI,IAAI,GAAG,CAAC;IAC5D;IAED,OAAO,UAAU,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,YAAY,CAAC;EACtE;EAED,MAAM,UAAU,GAAG,CAAA,EAAA,GAAA,OAAO,CAAC,OAAO,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAG,IAAI,CAAC;EAE1C,MAAM,YAAY,GACd,OAAO,UAAU,KAAK,QAAQ,GAAG,UAAU,GAAG,OAAO,CAAC,IAAI,CAAC;EAE/D,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE;IAClC,IAAI,IAAI,IAAI,IAAI,EAAE;MACd,MAAM,IAAI,KAAK,CAAC,UAAU,IAAI,6BAA6B,CAAC;IAC/D;IAED;IACA,MAAM,KAAK,GAAG,KAAK,CAAC,YAAY,CAAC;IACjC,OAAO,UAAU,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,YAAY,CAAC;EACvE;EAED,IAAI,OAAO,UAAU,KAAK,UAAU,EAAE;IAClC,gBAAgB,CAAC,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;IAE3C,OAAQ,IAAI,IAAK,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC;EACxD;EAED,IAAI,IAAI,IAAI,OAAO,EAAE;IACjB,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,IAAc,EAAE,OAAO,EAAE,OAAO,CAAC;EAC/D;EAED,IAAI,IAAI,IAAI,OAAO,EAAE;IACjB,MAAM,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAC5B,gBAAgB,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;IAEvC,OAAQ,IAAI,IAAK,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC;EAC7D;EAED,MAAM,IAAI,KAAK,CAAC,yBAAyB,IAAI,EAAE,CAAC;AACpD","sourceRoot":"https://raw.githubusercontent.com/fb55/css-select/0f0725a9dfeddd2fdb54eda9656cdbab5bbf6be6/src/","sourcesContent":["import { parse } from \"css-what\";\nimport { filters } from \"./filters.js\";\nimport { pseudos, verifyPseudoArgs } from \"./pseudos.js\";\nimport { aliases } from \"./aliases.js\";\nimport { subselects } from \"./subselects.js\";\nexport { filters, pseudos, aliases };\nexport function compilePseudoSelector(next, selector, options, context, compileToken) {\n    var _a;\n    const { name, data } = selector;\n    if (Array.isArray(data)) {\n        if (!(name in subselects)) {\n            throw new Error(`Unknown pseudo-class :${name}(${data})`);\n        }\n        return subselects[name](next, data, options, context, compileToken);\n    }\n    const userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];\n    const stringPseudo = typeof userPseudo === \"string\" ? userPseudo : aliases[name];\n    if (typeof stringPseudo === \"string\") {\n        if (data != null) {\n            throw new Error(`Pseudo ${name} doesn't have any arguments`);\n        }\n        // The alias has to be parsed here, to make sure options are respected.\n        const alias = parse(stringPseudo);\n        return subselects[\"is\"](next, alias, options, context, compileToken);\n    }\n    if (typeof userPseudo === \"function\") {\n        verifyPseudoArgs(userPseudo, name, data, 1);\n        return (elem) => userPseudo(elem, data) && next(elem);\n    }\n    if (name in filters) {\n        return filters[name](next, data, options, context);\n    }\n    if (name in pseudos) {\n        const pseudo = pseudos[name];\n        verifyPseudoArgs(pseudo, name, data, 2);\n        return (elem) => pseudo(elem, options, data) && next(elem);\n    }\n    throw new Error(`Unknown pseudo-class :${name}`);\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}