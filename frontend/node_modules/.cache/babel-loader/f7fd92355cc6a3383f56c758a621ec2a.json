{"ast":null,"code":"import { removeElement } from 'domutils';\nimport { Document, isDocument as checkIsDocument } from 'domhandler';\n/**\n * Get the parse function with options.\n *\n * @param parser - The parser function.\n * @returns The parse function with options.\n */\nexport function getParse(parser) {\n  /**\n   * Parse a HTML string or a node.\n   *\n   * @param content - The HTML string or node.\n   * @param options - The parser options.\n   * @param isDocument - If `content` is a document.\n   * @param context - The context node in the DOM tree.\n   * @returns The parsed document node.\n   */\n  return function parse(content, options, isDocument, context) {\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {\n      content = content.toString();\n    }\n    if (typeof content === 'string') {\n      return parser(content, options, isDocument, context);\n    }\n    const doc = content;\n    if (!Array.isArray(doc) && checkIsDocument(doc)) {\n      // If `doc` is already a root, just return it\n      return doc;\n    }\n    // Add conent to new root element\n    const root = new Document([]);\n    // Update the DOM using the root\n    update(doc, root);\n    return root;\n  };\n}\n/**\n * Update the dom structure, for one changed layer.\n *\n * @param newChilds - The new children.\n * @param parent - The new parent.\n * @returns The parent node.\n */\nexport function update(newChilds, parent) {\n  // Normalize\n  const arr = Array.isArray(newChilds) ? newChilds : [newChilds];\n  // Update parent\n  if (parent) {\n    parent.children = arr;\n  } else {\n    parent = null;\n  }\n  // Update neighbors\n  for (let i = 0; i < arr.length; i++) {\n    const node = arr[i];\n    // Cleanly remove existing nodes from their previous structures.\n    if (node.parent && node.parent.children !== arr) {\n      removeElement(node);\n    }\n    if (parent) {\n      node.prev = arr[i - 1] || null;\n      node.next = arr[i + 1] || null;\n    } else {\n      node.prev = node.next = null;\n    }\n    node.parent = parent;\n  }\n  return parent;\n}","map":{"version":3,"sources":["parse.ts"],"names":[],"mappings":"AAAA,SAAS,aAAa,QAAQ,UAAU;AACxC,SAEE,QAAQ,EAER,UAAU,IAAI,eAAe,QACxB,YAAY;AAGnB;;;;;AAKG;AACH,OAAM,SAAU,QAAQ,CACtB,MAKa,EAAA;EAEb;;;;;;;;AAQG;EACH,OAAO,SAAS,KAAK,CACnB,OAAyD,EACzD,OAAwB,EACxB,UAAmB,EACnB,OAA0B,EAAA;IAE1B,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;MAC7D,OAAO,GAAG,OAAO,CAAC,QAAQ,EAAE;IAC7B;IAED,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;MAC/B,OAAO,MAAM,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,OAAO,CAAC;IACrD;IAED,MAAM,GAAG,GAAG,OAAyC;IAErD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,eAAe,CAAC,GAAG,CAAC,EAAE;MAC/C;MACA,OAAO,GAAG;IACX;IAED;IACA,MAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,EAAE,CAAC;IAE7B;IACA,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC;IAEjB,OAAO,IAAI;EACb,CAAC;AACH;AAEA;;;;;;AAMG;AACH,OAAM,SAAU,MAAM,CACpB,SAA8B,EAC9B,MAAyB,EAAA;EAEzB;EACA,MAAM,GAAG,GAAG,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,SAAS,GAAG,CAAC,SAAS,CAAC;EAE9D;EACA,IAAI,MAAM,EAAE;IACV,MAAM,CAAC,QAAQ,GAAG,GAAG;GACtB,MAAM;IACL,MAAM,GAAG,IAAI;EACd;EAED;EACA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACnC,MAAM,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC;IAEnB;IACA,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,KAAK,GAAG,EAAE;MAC/C,aAAa,CAAC,IAAI,CAAC;IACpB;IAED,IAAI,MAAM,EAAE;MACV,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI;MAC9B,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI;KAC/B,MAAM;MACL,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI;IAC7B;IAED,IAAI,CAAC,MAAM,GAAG,MAAM;EACrB;EAED,OAAO,MAAM;AACf","sourceRoot":"https://raw.githubusercontent.com/cheeriojs/cheerio/d1cbc66d53392ce8bf6cd0068f675836372d2bf3/src/","sourcesContent":["import { removeElement } from 'domutils';\nimport { Document, isDocument as checkIsDocument, } from 'domhandler';\n/**\n * Get the parse function with options.\n *\n * @param parser - The parser function.\n * @returns The parse function with options.\n */\nexport function getParse(parser) {\n    /**\n     * Parse a HTML string or a node.\n     *\n     * @param content - The HTML string or node.\n     * @param options - The parser options.\n     * @param isDocument - If `content` is a document.\n     * @param context - The context node in the DOM tree.\n     * @returns The parsed document node.\n     */\n    return function parse(content, options, isDocument, context) {\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {\n            content = content.toString();\n        }\n        if (typeof content === 'string') {\n            return parser(content, options, isDocument, context);\n        }\n        const doc = content;\n        if (!Array.isArray(doc) && checkIsDocument(doc)) {\n            // If `doc` is already a root, just return it\n            return doc;\n        }\n        // Add conent to new root element\n        const root = new Document([]);\n        // Update the DOM using the root\n        update(doc, root);\n        return root;\n    };\n}\n/**\n * Update the dom structure, for one changed layer.\n *\n * @param newChilds - The new children.\n * @param parent - The new parent.\n * @returns The parent node.\n */\nexport function update(newChilds, parent) {\n    // Normalize\n    const arr = Array.isArray(newChilds) ? newChilds : [newChilds];\n    // Update parent\n    if (parent) {\n        parent.children = arr;\n    }\n    else {\n        parent = null;\n    }\n    // Update neighbors\n    for (let i = 0; i < arr.length; i++) {\n        const node = arr[i];\n        // Cleanly remove existing nodes from their previous structures.\n        if (node.parent && node.parent.children !== arr) {\n            removeElement(node);\n        }\n        if (parent) {\n            node.prev = arr[i - 1] || null;\n            node.next = arr[i + 1] || null;\n        }\n        else {\n            node.prev = node.next = null;\n        }\n        node.parent = parent;\n    }\n    return parent;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}